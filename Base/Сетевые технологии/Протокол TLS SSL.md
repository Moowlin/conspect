202105081550
Tags:
___
# Определения
**SL** — Secure Socket Layer, уровень защищенных сокетов
**TLS** — Transport Layer Security, безопасность транспортного уровня

**TLS/SSL** - протоколы безопасной передачи данных по небезопасной сети, обеспечивают: 
- Приватность (шифрование)
- Целостность
- Аутентификацию

По сути эти протоколы, TLS и SSL, работают одинаково, принципиальных различий нет.

# Шифрование
==Симметричное шифрование== - использование одного ключа для шифрования и дешифрования (разделяемый ключ)
 - ключ должен храниться в тайне
 - работет быстро

==Асимметричное шифрование== - используются два ключа - открытый и закрытый - открытым ключом шифрация, а закрытым - дешифрация
- открытый ключ может распространяться без ограничений
- работет медленно

Гибридное шифрование в TLS/SSL:
- Ассиметричное шифрование для передачи ключа симметричного шифрования
- Симметричное шифрование для передачи данных

Раньше использовали алгоритм RSA, но нашли уязвимости, и теперь используют алгоритм Диффи-Хеллмана

```python
g = 3 # открыто передается
p = 17 # открыто передается

Alice = 5
key_open1 = pow(g, Alice, p) # открыто передается

Bob = 6
key_open2 = pow(g, Bob, p) # открыто передается

key_secret1 = pow(key2, Alice, p) # полученный ключ для расшифровки
key_secret2 = pow(key1, Bob, p) # полученный ключ для расшифровки
```

# Целостность
Для проверки целотности искользуются хеш-функции.
==Криптографическая хеш-функция==- это математический алгоритм, который отображает данные произвольного размера в битовый массив фиксированного размера.

Для идеальной хеш-функции выполняются следующие условия:

- хеш-функция является детерминированной, то есть одно и то же сообщение приводит к одному и тому же хеш-значению  
- значение хеш-функции быстро вычисляется для любого сообщения  
- невозможно найти сообщение, которое дает заданное хеш-значение  
- невозможно найти два разных сообщения с одинаковым хеш-значением  
- небольшое изменение в сообщении изменяет хеш настолько сильно, что новое и старое значения кажутся некоррелирующими

А так как можно перехватить данные и хеш, изменить данные, а затем пересчитать хеш, то используется ==MAC (message authentication code)== - рассчитывается хеш на основе данных и закрытого ключа

Для хеширования строк в Python применяется библиотека [[Модуль haslib]]

# Аутентификация
Используется технология электронных подписей и инфраструктура открытых ключей.
 Электронные подписи используют асимметричное шифрование, но сообщение шифроуется закрытым ключом, а расшифровка происходит с помощью открытого ключа.
 ![[Pasted image 20210509182448.png]]
 
Сервер отправляет данные вместе с электронной подписью. Клиент с помощью открытого ключа дешифроует подпись, получает хеш, из полученного сообщения тоже вычисляет хеш и сравнивает оба хеша.

Однако нет защиты от человека по середине, который мог выдать нам открытый ключ. И тут приходит инфрастурктура открытых ключей, состоящая из недоверчивых друг к другу узлов и удостоверяющего центра, которому все доверяют. 

![[Pasted image 20210509183032.png]]
А так как в интернете много народу. то одного центар мало, поэтому их много =) С узлами работают удостоверябщие центры, которым сертификат доверия выдал корневой центр - путь сертификации, и весь этот путь проверяет клиент при получении сетификата от сервера.
А сертификат корневого центра прописывается в ОС.
![[Pasted image 20210509184424.png]]

# Принцип работы SSL и TLS
Принцип работы SSL и TLS, как я уже сказал, один и тот же. Поверх протокола TCP/IP устанавливается зашифрованный канал, внутри которого передаются данные по прикладному протоколу — HTTP, FTP, и так далее.

Протокол TLS состоит из двух уровней:
![[Pasted image 20210509193927.png]]
Нижний уровень содержит **Протокол записей** (*Record protocol*) , задающий формат, в котором данные будут передаваться по сети.


Верхний уровень состоит из 4 протоколов, определяющие какое содержаниебедет передаваться:
- **Протокол установки соединения** (*Handshake protocol*) - для установки соединения TLS между клиентом и сервером
- **Протокол оповещения** (*Alert protocol*)- для передачи ошибок и предупреждения в случае некорректной работы
- **Протокол смены шифра** (*Change cipher protocol*)- необходим чтобы перейти от одного шифрования на другое
- **Протокол передачи данных** (*Application data protocol*) - для передачи данных в зашифрованном виде


## Подробнее о нижнем уровне TLS
**Протокол записей** (*Record protocol*) является основой TLS, в нем реализованы алгоритмы шифроввания и целостности данных с помощью MAC.
В записи Record protocol вкладываются сообщения вышестоящих протоколв TLS, а затем сообщения протокола записей вкладываются в сегменты TCP.

![[Pasted image 20210509212148.png]]
*Тип сообщения* - указывает какой вышестоящий протокол TLS используется
*Версия протокола* - версия TLS
*Длина сообщения* - длина передаваемого сообщения. Тут есть уязвимость, так как по длине сообщения можно вычислить сообщения (зависит от конкретного прикладного протокола), лучше использовать фиксированную длину

## Протокол передачи данных (*application data protocol*)
![[Pasted image 20210509213354.png]]
1. Клиент получает от вышестоящего протокола (например от HTTPS), данные, которые могут быть достаточно большого объема, а потому протокол передачи данных разбивает их на отдельные фраменты - сообщения,  которые можно передать в сеть за один раз.
2. с помощью ключа МАС вычисляется код идентификации сообщения МАС и присоединяется к сообщению
3. с использованием ключа симметричного шифрования сообщение+МАС шифруется
4. зашифрованное сообщение передается по сети
5. сервер получает сообщение и дешифрует его с помощью ключа симметричного шифрования
6. затем с помощью клюа МАС расшифровывает МАС и проверяет целостность полученных данных
>порядок сначала вычисление МАС, а потом шифрование использовался до версии TLS1.2
7. Полученное сообщение записываем в буфер
8. затем получаем остальные сообщения и рашифровываем их
9. объединяем сообщения в данные и передаем все вышестоящему протоколу

## Протокол оповещения (*Alert protocol*)
Нужен для оповещения об ошибках в работе TLS
- *Фатальные ошибки* - сессия должна быть немедленно разорвана:
	- ошибка MAC (*bad_record_mac*)
	- неизвестный удостоверяющий центр (*unknown_ca*)
	- ошибка расшифровки (*decrypt_error*)
- *Предупреждения* - сессия может продолжать работать:
	- срок действия сертификата завершен (*certificate_expired*)
	- сертификат отозван (*certificate_revoked*)
	- неизвестный формат сетификата (*unsupported_certificate*)



## Установка сессии TLS
1. Создание сессии:
	- Устновка соединения с помощью Handshake protocol
	- Возобновление соединения, которое было установлено ранее
2. Надо договориться какой набор шифров TLS будет использоваться:
	- алгоритм обмена ключами (Диффи_Хеллман)
	- алгоритм цифровой подписи (RSA)
	- алгоритм симметричного шифрованя (AES)
	- хеш-функция для MAC (SHA-256)
3. Необходимо иметь разделяемы ключи:
	- ключи для симметричного шифрования
	- ключи для MAC
4. Описание сессии:
	- идентификатор сессии
	- узел, с которым установлено соединение

###  Установка сессии TLS1.2
1.  Между клиентом и сервером устанавливается TCP-соединение
2.  Клиент отправляет на сервер сообщение *Hello Client*, а также случайное значение клиента и поддерживаемые комплекты шифров.
3.  Сервер отвечает, отправляя клиенту сообщение *"Server Hello"*, а также случайное значение сервера, выбранный шифр TLS, идентификатор сессии
4.  Сервер отправляет клиенту сообщение *"Certificate"* сертификат для проверки подлинности и может запросить сертификат у клиента. 
5.  Клиент проверяет полученный сертификат:
	- проверк подлинностей удостоверяющих центров
	- проверка доверия корневому удостоверяющему центру
	- проверка домена сертификата
	- проверка срока дейтсвия сертивика
	- проврека, не отозвван ли сетртифкат
6.  Сервер передает сообщение *"Server key Exchange"* данные для обмена ключами - это необязательное соединение (если **RSA** - используется открытый ключ сервера, который прописан в сертификате и тогда от сервера дополнительная информация не нужна, если **DH: в статическом варианте** p,g находятся в сертификате сервера, а Y -закрытый ключ - передает сервер, если **DH с одноразовыми параметрами**, то значения p,g,Y сервер передает)
7.  Сервер отправляет сообщение *"Hello Server Done"*.
8.  Если сервер запросил сертификат от клиента, клиент отправляет его.
9.  *"Client Key Exchange"* Если **RSA**: клиент генерирует **pre-master secret**  (это предварительный ключ на основе которого будут рассчитаны ключи симметричного шифрования), затем на основе открытого ключа сервера в сертификате шифрует его и передает на сервер, сервер с  помошью закрытого ключа дешифрует его и получет **pre-master secret**. Если **DH**, клиент передает число, полученно по методу DH, затем все расчитывают  **pre-master secret**, на основе которого рассчитываются ключи симметричного шифрования и ключи MAC
10.  клиент отправляет *"Change cipher spec"* - переключиться на защищенное соединение
11.  Клиент также отправляет сообщение *"Client finished"*.
12.  Сервер получает "изменить спецификацию шифра" и переключает состояние безопасности уровня. Сервер отправляет клиенту сообщение *"Server Finished"*.
![[Pasted image 20210509225515.png]]

###  Разрав соединения TLS
1. Клиент отправляет сообещение '*'close_notify"* и перестает реагировать на какие-либо ответные сообщения
2. Сервер после  получения сообещение '*'close_notify"*  обязан отправить ответное сообещение '*'close_notify"*  и закрыть соединение

###  Восстановление соединения TLS
1.  Между клиентом и сервером устанавливается TCP-соединение
2.  Клиент отправляет на сервер сообщение *Hello Client* и идентификатор сессии
3.  сервер проверят идентификатор в таблице сохраненных идентификаторов и если находит,то высылает в ответ сообщения *"Server Hello"*, *"Change cipher spec"* и *"Server Finished"* причем зашифровано ключом симметричного шифрования и МАС
4.  клиент расшифровывает сообщение, проверяет целостность и если все успешно от отправляет *"Change cipher spec"* и *"Client finished"*


###  Установка сессии TLS1.3
![[Pasted image 20210509230848.png]]

1.  Как и в случае TLS 1.2, сообщение «Client Hello» запускает рукопожатие, но на этот раз оно содержит гораздо больше информации. TLS 1.3 сократил число поддерживаемых шифров с 37 до 5. Это значит, что клиент может угадать, какое соглашение о ключах или протокол обмена будет использоваться, поэтому в дополнение к сообщению отправляет свою часть общего ключа из предполагаемого протокола.
2.  Сервер ответит сообщением «Server Hello». Как и в рукопожатии 1.2, на этом этапе отправляется сертификат. Если клиент правильно угадал протокол шифрования с присоединёнными данными и сервер на него согласился, последний отправляет свою часть общего ключа, вычисляет сеансовый ключ и завершает передачу сообщением «Server Finished».
3.  Теперь, когда у клиента есть вся необходимая информация, он верифицирует SSL-сертификат и использует два общих ключа для вычисления своей копии сеансового ключа. Когда это сделано, он отправляет сообщение «Client Finished».

А если клиент в первом шаге не угадал, то сервер просит сказать привет еще раз и указывает набор шифров, которые хочет использовать и дает инфу о генерации ключа

![[Pasted image 20210509231145.png]]

## Нулевое время возобновления приёма-передачи — 0-RTT
для возобновления сессии
![[Pasted image 20210509231444.png]]




# Ссылки

___
##### Links
[[Протокол TCP]]

---
##### Источники

[Вводная лекция по семейству протоколов TLS/SSL](https://www.youtube.com/watch?v=LTLqazCztnc)
[Лекция по шифрованию в семействе протоколов TLS/SSL](https://www.youtube.com/watch?v=57cUndFt-Ak)
[Лекция по защите от изменений данных в семействе протоколов TLS/SSL](https://www.youtube.com/watch?v=57cUndFt-Ak)
[Лекция по подтверждению подлинности сервера в TLS/SSL](https://www.youtube.com/watch?v=6wCwjIhGylY)
[Лекция по протоколу TLS](https://www.youtube.com/watch?v=FrHEXXTvW4c)
[Лекция об установке соединения в протоколе TLS](https://www.youtube.com/watch?v=lKfyM980cOw)
[Лекция по современной версии протокола TLS 1.3](https://www.youtube.com/watch?v=vs65xb5mkdo)



https://mnorin.com/tls-ssl-neobhodimy-j-minimum-znanij.html
https://habr.com/ru/post/258285/
https://tls.dxdt.ru/tls.html
