202201241430
Tags:
___
# Протокол TCP

TCP — расшифровывается как (Transmission Control Protocol) протокол управления передач. В отличии от UDP, TCP обеспечивает надежную доставку данных. Сервис предоставляемый TCP называются надежная передача потока байт или (reliable byte stream) по-английский. 
>TCP обеспечивает как гарантию доставки данных, так и гарантию сохранения порядка следования сообщений.

## Поток байт
От приложения, протокол TCP получает поток байт, который может быть очень большим. Например, вы можете скачивать из интернета файл, который составляет несколько мегабайт или несколько гигабайт. Данные файлы приходят на транспортный уровень в виде одного большого потока байт.

![[Pasted image 20220124152343.png]]

В протоколе TCP поток байт делится на отдельные части, которые называются сегменты. Каждый сегмент отправляется отдельно получателю. Получатель со своей стороны, принимает сегменты, собирает их в один большой поток байт и отправляет этот поток байт приложению.

## Гарантия доставки 
### подтверждение получения

Для того чтобы обеспечить гарантию доставки данных, TCP использует подтверждение получения сообщения.

Отправитель пересылает по сети некоторый сегмент данных, получатель принимает сегмент и посылает отправителю подтверждение, сокращенно ACK от английского **Acknowledgment**, которая говорит о том что сегмент данных получен. Затем отправляется следующий сегмент данных, снова подтверждение и так далее.

### повторная отправка

Сегмент данных потерян в сети, он не доходит до получателя, получатель не отправляет подтверждение сообщения. Отправитель при отправке сегмента устанавливает таймер, который задает время ожидания подтверждения, если в течении этого времени подтверждение не пришло, таймер срабатывает и тот же самый сегмент отправляются повторно.


## Порядок следования сообщений
Подтверждение и провторная отправка обеспечивает только защиту от потери сегментов, а этого недостаточно для надежной передачи потока байт. Необходимо также обеспечить порядок следования сообщений. Нарушение может возникнуть в результате *дублирования сегментов* или *сегменты приходят в неправильном порядке*

**Дублирование сегментов** может возникнуть в результате получения сегмента, но возникновения ошибки при передачи сообющения ACK
![[Pasted image 20220124153517.png]]

> Решение - нумерация сообщений. *Нумеруются не сегменты, а байты*

![[Pasted image 20220124153631.png]]
![[Pasted image 20220124153722.png]]

По номерам байтов получатель всегда может выставить сегменты в правильной последовательности 

# Соединение TCP
Для передачи данных используется соединение, которое необходимо завершить после передачи данных
**Задачи соединения:**
- убедиться, что отправитель и получатель хотят передавать данные друг другу
- договориься о нумерации потока байт
- договориься о параментрах соединений (максимальный размер сегмента и т.д.)

## Установка соединения TCP
Отправитель посылает запрос на установку соединения сообщение SYN от слова синхронизация. Также в сегмент включаются порядковый номер передаваемого байта.
Получатель в ответ передаёт сообщение SYN, куда включает подтверждение получения предыдущего сообщения ACK от слова acknowledge и порядковый номер байта, который он ожидает 7538, потому что на предыдущем этапе был получен байт с номером 7537.

![[Pasted image 20220124165513.png]]

Также отправитель включает в сегмент номер байта в потоке байт 36829. Номера байт в первом сообщении не могут быть всегда нулевыми, они выбираются по достаточно сложным алгоритмам, но для простоты можно представлять себе что эти номера выбираются случайным образом.
На третьем этапе пересылается подтверждение получения предыдущего запроса на установку соединения ACK номер следующего ожидаемого байта 36830, а также номер байта в сообщении. После этого соединение считается установленным и можно передавать данные.

## Разрыв соединения в TCP
Соединение в TCP дуплексное — это означает, что после установки соединения передавать данные можно в две стороны. Есть две схемы разрыва соединения:
1. *одновременный* разрыв соединения, в этом случае обе стороны разрывают соединение в одно и то же время
2. *односторонние*, в этом случае одна сторона говорит о том, что данные для передачи у нее закончились, но другая сторона может передавать данные еще достаточно долго

Протокол TCP предусматривает два варианта разрыва соединения: 
1. корректное, с помощью одностороннего разрыва соединения и сообщения *FIN* 
2. разрыв из-за критической ситуации с помощью сообщения *RST*

# Скользящее окно

Подтверждается не каждый сегмент, а несколько сегментов следующие друг за другом, этот механизм называется скользящее окно.
-   Остановка и ожидание (Wi-Fi, канальный уровень)
	-    Получатель присылает подтверждение после этого передается следующая порция данных. Снова подтверждение, снова данные и снова подтверждение.
-   Скользящее окно (TCP, транспортный уровень)
	-   В этом случае отправитель передает сразу несколько порций данных не дожидаясь подтверждения. Получатель отправляет одно подтверждение которое называется кумулятивное. Это означает, что получатель получил последнюю порцию данных и все предыдущие.


![[Pasted image 20220124163943.png]]

![[Pasted image 20220124164103.png]]

## Тип подтверждения

Есть два типа подтверждения, которые могут использоваться совместно с алгоритмом скользящего окна:
1. **Кумулятивное подтверждение**
	говорит о том что получен указанный байт данных и все предыдущие. Такой подход используется в TCP по умолчанию.
2. **Выборочное подтверждение**
	В этом случае получатель подтверждает получение диапазона принятых байт. Выборочное подтверждение эффективно при большом размере окна TCP, но выборочное подтверждение по умолчанию не используется для этого необходимо применение дополнительных полей заголовка TCP, которые называются параметрами.


# Формат заголовка
![[Pasted image 20220124170338.png]]
Первые два поля _порт отправителя_ и _порт получателя_. Порты это адреса на транспортном уровне они позволяют определить к какому приложению предназначен сегмент.
Следующее поле _порядковый номер_. TCP нумерует байты в потоке, и в поле порядковый номер содержится первый номер байта в сегменте.
Следующее поле _номер подтверждения_, подтверждение используется для обеспечения гарантии доставки сообщений. Отправитель передает сегмент с указанием номера последовательности.
![[Pasted image 20220124170522.png]]

Затем идет поле _длина заголовка_, как и в случае с IP, заголовок TCP состоит из двух частей, _обязательной_ и _необязательной_. Длина обязательной части заголовка 20 байт, длина необязательный может быть разной в том числе и нулевой. Поэтому мы должны знать общую длину заголовка TCP.


Затем идут три _зарезервированных бита_, которые сейчас не используется. И 9 полей флагов:
-   Флаги _NS_, _CWR_ и _ECE_ используются для управления перегрузкой.
-   Флаг _URG_  указывает на то, что в сегменте содержатся срочные данные, которые необходимо быстро передать приложению. Этот флаг используется совместно с полем _указатель на срочные данны_е, который содержит адрес этих данных. Сейчас этот флаг и поле указатель на срочные данные не используются.
-   Флаг _ACK_ используются, если в поле _номер подтверждения_ записаны осмысленные данным, то есть для подтверждения принятой ранее информации.
-   Флаг _PSH_ указывает, что полученные данные необходимо полностью сразу передать приложение без промежуточной записи в буфер, также как и флаг _URG_ этот флаг сейчас не используется.
-   Флаги _RST_ и _FIN_ используются для разрыва соединений, а флаг _SYN_ синхронизация, используется для установки соединения.

Следующее поле _размер окна_, в этом поле получатель указывает сколько данных он может принять. Поле используется для управления потоком.

Затем идет _контрольная сумма_, которая используется для проверки правильности доставки данных, если контрольная сумма рассчитанная получателем не совпадает с контрольной суммой в заголовке TCP, то этот сегмент отбрасывается.
Поле _указатель на срочные данные_, которую мы рассмотрели, завершают обязательную часть заголовка TCP.


Затем идет не обязательная часть заголовка, которая в TCP называется _параметры_. В отличии от IP, где опции используются редко, параметры в TCP используется часто.

Рассмотрим некоторые примеры параметров:

Параметры (Maximum Segment Size, MSS) _максимальный размер сегмента_, говорит о том сегмент какого размера может принять получатель, если используется Ethernet, то максимальный размер сегмента 1460 байт. Максимальный размер сегмента, задается отправителем и получателем при установке соединения.

Другой важный параметр это _масштаб окна_, поле размер окна в заголовке TCP позволяет указать максимальный размер доступных для получения байт 65535, но это маленький объем для современных высокоскоростных и территориально протяженных каналов. Если использовать размер окна такого размера то, скорость передачи данных будет низкая. Параметр масштаб окна позволяет увеличить размер окна до 1 ГБ.

Другой полезный параметр это _выборочное подтверждение_, позволяет получить подтверждение диапазонов принятых байт, а не всех данных до определенного байта. Выборочное подтверждение полезно, если потерян всего лишь один сегмент или небольшая порция в большом потоке данных.

# Управление потоком
Управление потоком TCP для повышения скорости работы в быстрых сетях используют скользящее окно. При этом отправитель передает в сеть большое количество сегментов не дожидаясь подтверждения и эти сегменты хорошо занимают пропускную способность широкого канала.
Но что произойдет, если получает данные не высокопроизводительный сервер, а маленький телефон, смартфон, планшет или какое-то другое медленное устройство? В этом случае получатель примет несколько сегментов, а остальные будет вынужден отбросить.
Задача предотвращения отправки быстрым отправителем слишком большого количества сегментов, которые не могут быть получены медленным получателем, так называемого “затопления” в TCP называется *управление потоком (flow control)*

 В отличии от сетевого и канального уровня, где коммутаторы или маршрутизаторы должны обрабатывать данные сразу же как только они пришли и делать это максимально быстро, приложение не обязано читать данные сети, как только они появились.
 ![[Pasted image 20220203170510.png]]
 
 Данные, которые приходят из сети записываются в некоторый промежуточный буфер, откуда их со временем должно прочитать приложение.
 ## Размер окна в заголовке TCP
Нам нужен механизм, который позволяет получателю, сказать, сколько же данных он может принять для того чтобы отправитель не передавал слишком много данных. Для этой цели используется поле размер окна в заголовке TCP. В этом поле отправитель указывает сколько байт данных он может принять.
![[Pasted image 20220203170705.png]]

Рассмотрим, как используются это поле на практике. Предположим, что размер буфера у получателя равен восьми сегментам. Отправитель передает один сегмент он записывается в буфер, получатель передает подтверждение получение этого сегмента. В подтверждение, кроме номера следующего ожидаемого байта, указывается также размер окна 10 220 что соответствует семи сегментам (7\*1460). Мы используем сеть Ethernet, в который размер кадра 1500 байт, если вычтем заголовок TCP 20 байт и IP 20 байт, размер данных сегмента получится 1460 байт.
![[Pasted image 20220203170801.png]]
Затем отправитель передает сразу четыре сегмента, они записываются в буфер. Получатель отправляет подтверждение, где указывает новый размер окна, который равен всего трем сегментам.
![[Pasted image 20220203170828.png]]

Предположим, что приложение занято какими-то делами и ничего из буфера не читает.

-   Отправитель передает три сегмента, они записываются в буфер и в буфере место заканчивается.
-   Получатель, передавая подтверждение, указывает, что размер окна равен нулю, этим он говорит отправителю, чтобы тот остановился и пока ничего не передавал.
-   Отправитель делает паузу и ждет следующего сообщения. Приложение прочитало часть данных из буфера, освободилось место для двух сегментов.
-   Получатель заново отправляет подтверждение последнего принятого байта и указывает новый размер окна, равны двум сегментам.
-   Отправитель передает эти два сегмента, которые снова записываются в буфер.
-   Отправитель, если ждет слишком долго, может передать, так называемый, сегмент Zero Window Probe просьба подтвердить, что размер окна все еще равен нулю. Он передается для того, чтобы убедиться, что получатель остается на связи и не произошло каких-то ошибок.
-   В ответ на сегмент Zero Window Probe получатель может отправить сообщение, что размер окна по-прежнему равен нулю, это значит отправитель должен ждать либо новый размер окна, значит отправитель может передавать данные.


# Управление перегрузкой
Получатель, при отправке каждого подтверждения, указывает в сегменте размер окна, количество байт, которые он может принять. Отправлять больше данных в сеть не имеет смысла.
Но возможна и другая проблема. В буфере получателя может быть достаточно свободного места, но сеть, через которую передаются данные, перегружена.
![[Pasted image 20220203171008.png]]

## Коллапс перезагрузки
Чтобы решить эту проблему, стали учитывать загрузку сети при формировании размера окна, то есть при определении количества сегментов, которые можно отправить в сеть, не дожидаясь получения подтверждения.

Если раньше, до коллапса перегрузки, такое количество сегментов всегда было одинаково 8 штук, то после коллапса перегрузки решили, что это количество нужно определять динамически в зависимости от того загружена сеть или нет. И для того чтобы определить количество сегментов, которое можно отправить в сеть, используется окно перегрузки.

## Окно перегрузки в TCP
Таким образом в  TCP у нас есть два типа окна: 
1. Окно управления потоком - Размер этого окна задаются получателем, в зависимости от того сколько места в буфере, и передается отправителю в сегментах с подтверждением.
2. Окно перегрузки, существует на стороне отправителя, его размер рассчитывается отправителем в зависимости от того, какая нагрузка на сеть, а не от того сколько данных может принять приложение.

##  Управление скоростью передачи в CP

Оба типа окна, окно управления потоком и окно перегрузки, используются для решения более общей задачи — управление скоростью передачи данных в TCP. Если размер скользящего окна будет слишком маленьким, то в сеть мы будем отправлять маленькое количество сегментов, сеть будет не загружена полностью, и скорость передачи будет маленькой, ниже чем возможно.

С другой стороны, если мы будем отправлять в сеть большое количество сегментов, то сеть может оказаться перегруженной, маршрутизаторы начнут отбрасывать наши сегменты, их нужно будет отправлять заново и скорость передачи данных опять окажется низкой. Таким образом нам нужно определить оптимальный размер окна, для того чтобы мы могли передавать данные по сети избегая загрузки, и приложение могло принять эти данные, и записать их в свой буфер.

## AIMD
В TCP для определения размера окна перегрузки используется метод аддитивного увеличения, мультипликативного уменьшения. Суть метода заключается в том, что при получении каждого подтверждения, мы прибавляем к размеру окна некоторые значения, как правило это размер одного сегмента TCP, а если перегрузка произошла, то мы умножаем размер окна на некоторые значения. Как правило это 1/2, то есть в TCP при перегрузке, размер окна уменьшается в два раза.
![[Pasted image 20220203171208.png]]
-   Где a — максимальный размер сегмента (MSS);
-   b- 1/2.

### Размер окна AIMD
Вот график работы метода аддитивного увеличения, мультипликативного уменьшения. Мы начинаем передавать данные, поступает подтверждение,размер окна увеличивается, происходит аддитивное увеличение. Затем в сети произошла перегрузка, размер окна уменьшается в два раза, произошло мультипликативное уменьшение.
![[Pasted image 20220203171235.png]]

##  Сигнал о перезагрузке

Как отправитель узнает, о том что в сети произошла перегрузка? Это достаточно сложная задача, потому что сеть может быть составной, и перегрузка может происходить не на том сегменте сети, который подключен к отправителю, а на каком-то сегменте между отправителем и получателем, который находятся достаточно далеко от того и другого.

Чаще всего на практике, в качестве сигнала перегрузки используется *потеря сегмента*. Считается, что сейчас каналы связи уже хорошего качества и если произошла потеря сегмента, то не из-за ошибки канала, а из-за того, что сеть перегружена, поэтому нужно уменьшить размер окна, для того чтобы избежать дальнейшей перегрузки.

## Медленный старт
Метод аддитивного увеличения мультипликативного уменьшения хорошо работал на медленных каналах связи, которые были во времена создания сети интернет, но у на современных, быстрых и надежных каналах связи, этот метод работает плохо. С помощью аддитивного увеличения, размер окна перегрузкой увеличивается очень медленно, для того чтобы решить эту проблему был предложен другой метод управления размером окна — медленный старт.

При медленном старте размер окна увеличивается на каждое подтверждение не на 1 сегмент, а на 2, благодаря этому происходит экспоненциальное увеличение размера окна. Сначала мы отправляем один сегмент, получили подтверждение, отправляем два сегмента, получили 2 подтверждения, на каждое подтверждение отправляем по два сегмента всего 4, потом 8, потом 16 и так далее. То есть несмотря на название медленный старт, размер окна увеличивается гораздо быстрее, чем при аддитивном увеличении, мультипликативном уменьшении.

Недостаток метода заключается в том, что если произошла потеря сегмента, то размер окна уменьшается до нуля. Таким образом медленный старт быстро разгоняется, но также быстро тормозится.

### Медленный старт и AIMD в TCP
В TCP используется комбинация медленного старта и аддитивного увеличения мультипликативного уменьшения. Cначала используется медленный старт, для того, чтобы быстро заполнить доступную пропускную способность канала. После того, как размер окна достиг определенного значения, порог медленного старта, происходит переход на аддитивное увеличение мультипликативное уменьшение. И дальше уже используется этот метод, размер окна увеличивается медленно, но если пришел сигнал о перегрузке, размер окна уменьшается в два раза, а не снижается до нуля.

![[Pasted image 20220203171521.png]]
Порог медленного старта определяется следующим образом. Сначала запускается медленный старт и работает до того, пока не поступит сигнал о перегрузке, после этого размера окна при котором пришел сигнал о перегрузке делится в два раза, и это значение выбирается порогом медленно старта. Таким образом, формируется достаточный запас размера окна, для того чтобы не произошла перегрузка, которые при аддитивном увеличении скорее всего не будет достигнут, если конечно загрузка сети останется на том же самом уровне.

## Проблемы сигнала «потеря сегмента»
Если использовать потерю сегментов в качестве сигнала и перегрузки, то TCP фактически будет работать в режиме, который ведёт к перегрузке. TCP постоянно увеличивает размер окна пока перегрузка не произойдет, причем о перегрузке TCP узнает только после того, как она произошла, поэтому предотвратить ее при такой схеме нельзя.

Другая проблема называется глобальной синхронизацией TCP и TCP global synchronization, она заключается в том, что когда на маршрутизаторе на котором произошла перегрузка заканчивается место в буфере, он отбрасывает сегменты всех отправителей.

Отправитель обнаруживает потерю сегмента, понимает что произошла перегрузка уменьшает размер окна. В TCP в отличии от Ethernet или wi-fi, не встроена схема рандомизированное задержки, поэтому все отправители после уменьшения размера окна начинают передавать данные примерно в одно и то же время. В результате на маршрутизатор опять приходит большое количество пакетов, что в свою очередь ведет к перегрузке. Для того чтобы решить эти проблемы используются другие сигналы о перегрузке, которые мы сейчас рассмотрим.

## Задержка сегмента
Один из возможных вариантов, задержка сегмента. В этом случае измеряется round trip time (RTT) время движения сегмента от отправителя до получателя и обратно.
![[Pasted image 20220203171618.png]]

Отправитель передавая сегменты, засекает RTT, измеряет средние время, и при существенном увеличении RTT уменьшается размер окна перегрузки.
Измерение времени задержки сегмента, позволяет обнаружить перегрузку до того как она произошла, но задержка может быть вызвана не только перегрузкой, но и другими причинами. Поэтому задержка сегмента не такой надежный сигнал, как его потеря.

Другая проблема заключается в том, что когда мы используем такой сигнал о перегрузке на загруженных каналах связи, то это приводит к не справедливому распределению пропускной способности. Наш компьютер начинает уменьшать размер окна перегрузки, когда увеличивается время задержки сегмента, в то же время другие компьютеры, которые используют сигнал о перегрузке потери сегмента, продолжают увеличивать размер окна пока перегрузка не произойдет.

Решением является совместное использование двух сигналов задержки и потери сегмента, такой подход используется например, в протоколе Compound TCP реализованного компанией Microsoft.

## Сигнал о перегрузке
Следующий вариант, как отправитель может узнать о перегрузке это явный сигнал от маршрутизатора. Однако для этого маршрутизаторы должны поддерживать отправку сигналов. Одним из возможных вариантов является технология Random Early Detection, при этом маршрутизатор с некоторой вероятностью начинает отбрасывать пакеты еще до того как буфер полностью заполнен и началась перегрузка.

В результате отправители узнают о возможной перегрузке по потере сегмента ещё до того, как она произошла, и получают возможность заранее уменьшить окно перегрузки. Но это не явный тип сигнала, технологиях Explicit Congestion Notification, обеспечивает явную отправку сигнала от маршрутизатора к отправителю, о том что в сети происходит перегрузка.

### Explicit Congestion Notification (ECN)
Рассмотрим на схеме, как она работает. Отправитель передает сегмент в сеть, который доходит до маршрутизатора. Маршрутизатор находится в состоянии близкому к перегрузке, буфер заполнен, но не полностью. Для того чтобы предупредить отправителя о перегрузке в сети, маршрутизатор устанавливать специальные флаги в заголовке IP, которые говорят о том, что в сети произошла перегрузка.
Сегмент передается по сети дальше и достигает получателя. Получатель в заголовке IP видит что установлен флаг, свидетельствующий о перегрузке, для того чтобы о перегрузке узнал не только получатель, но и отправитель, получатель устанавливает соответствующие флаги уже в заголовке TCP, когда передает подтверждение.
![[Pasted image 20220203171721.png]]
Отправитель получает подтверждение доставки сообщения, и в этом подтверждении он видит, что флаг сигнализирующий о перегрузке установлен, это будет сигналом о том что нужно уменьшить размер окна перегрузки.

### ECN в заголовке P

Рассмотрим, какие поля в заголовке IP и TCP используются в технологии Explicit Congestion Notification. В заголовке IP используются 2 бита в поле тип сервиса, значение 00 говорит о том, что перегрузки нет, а 11 означают что перегрузка произошла.

![[Pasted image 20220203171736.png]]

### ECN в заголовке CP

В заголовке TCP для этих целей используются три флага, NS, CWR, ECE.
![[Pasted image 20220203171752.png]]
-   Получатель, который принял от маршрутизаторов заголовки IP сигнал о перегрузке, использует флаг ECE (ECN-Echo). Получатель устанавливает этот флаг в подтверждение получения сегмента, который он передает отправителю.
-   Отправитель в качестве подтверждения того, что он получил сообщение о перегрузки при передаче следующего сегмента устанавливает флаг CWR (Congestion Window Reduced), который говорит о том, что размер окна управление перегрузкой уменьшен.
-   Еще один флаг NS (ECN-none concealment protection) используется для защиты от случайного или злонамеренного изменения полей, который относится к технологии Explicit Congestion Notification.



# Ссылки
___
##### Links
[[Сетевое программирование]]


---
##### Источники
https://zvondozvon.ru/tehnologii/protokoli/tcp-upravlenie-potokom

https://zvondozvon.ru/tehnologii/kompyuternye-seti/protokol-servis-interfeis