202204111639
Tags:
___
# Head

HEAD - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данным момент работаем.

HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.


_HEAD_ указывает на коммит, относительного которого будет создана рабочая копия во-время операции _checkout_. Другими словами, когда вы переключаетесь с ветки на ветку, используя операцию `checkout`, то в вашем репозитории указатель _HEAD_ будет переключаться между последними коммитами выбираемых вами ветвей.

![[git-head-pic3.png]]
` git checkout 2b826bb`

![[git-head-pic4.png]]

https://devpractice.ru/git-for-beginners-part-7-head-and-tree-ish/


# Cherry-pick

 `git cherry-pick <Commit1> <Commit2> <...>`

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (`HEAD`). Мы обожаем `cherry-pick` за то, что в нём очень мало магии и его очень просто понять и применять.

# Rebase
https://habr.com/ru/post/161009/


# Жонглируем коммитами

Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (`newImage`) и другие изменения (`caption`), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять `newImage`, несмотря на то, что коммит уже в прошлом!

Преодолеть эти трудности можно следующим образом:

-   Переставить коммит так, чтобы нужный находился наверху при помощи `git rebase -i`
-   Внести изменения при помощи `git commit --amend`
-   Переставить всё обратно при помощи `git rebase -i`
-   И наконец, переместить main на изменённую часть дерева, чтобы закончить уровень.

Это задание можно выполнить несколькими способами (и, гляжу, ты посматриваешь на cherry-picking), но сейчас сосредоточься на вышеописанном методе.

Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем `git commit --amend`.

Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.

### Git Describe

Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, как далеко текущее состояние от ближайшего тега. И эта команда называется `git describe`

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали `git bisect` или если вы недавно вернулись из отпуска =)

Git describe выглядит примерно так:

`git describe <ref>`

Где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`).

Вывод команды выглядит примерно так:

`<tag>_<numCommits>_g<hash>`

Где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается.

# Git для самых маленьких
-   `git commit` — создание коммита (снимка проекта).
    -   У каждого коммита есть свой родительский коммит.
-   `git branch newBranch` — создание ветки (ссылки на определенный коммит).
    -   Ведение проекта следует организовывать именно через ветки.
    -   Ветка хранит набор коммитов и их родителей.
    -   Следует разбивать множество маленьких работ на множество не потребляющих памяти или места на диске веток.
    -   Звездочка рядом с названием ветки указывает на то, что сейчас используется именно эта ветка.
-   `git checkout [name]` — выбор ветки.
-   `git merge newBranch` — объединение изменений из 2х разных веток-родителей, а именно — из newBranch в Master (делается из master).
    -   Цель слияния — создать свою ветку, сделать необходимые изменения с помощью череды коммитов, и слить новый функционал с основным проектом.
    -   Основная ветка проекта называется master (открывается в проекте по умолчанию при его первоначальном создании).
-   `git rebase newBranch` — копирование набора коммитов из одной ветки в другую.
    -   Используется для создания чистых красивых последовательностей коммитов, чтобы история коммитов делалась последовательно, хотя на самом деле — параллельно.
    -   Следует предварительно выбирать ветку, коммиты которой будут копироваться в другую ветку. Затем сделать rebase, выбрать ту ветку, в которую произошло копирование, и сделать rebase с уже ранее скопированной веткой.
-   Перемещение по коммитам.
    -   `git checkout master^` — перемещение на 1 коммит от текущего коммита,
    -   `git checkout master^^` — перемещение на 2 коммита от текущего и т.д.,
    -   `git checkout newBranch~4` — перемещение на 4 коммита вверх от текущего.
-   Перемещение ветки.
    -   `git branch -f master newBranch~4` — перемещение ветки master к коммиту на 3 родителя назад от newBranch.
-   Отмена изменений.
    -   `git reset` — отменяет изменения, переносясь на предыдущий коммит, как будто текущего коммита и не было. Работает исключительно для локальных веток.
    -   `git revert` — отменяет изменения таким образом, чтобы всем пользователям была видна отмена изменений. Появляется новый коммит, который содержит противоположные изменения текущему коммиту. После следует ввести команду `git push`.
-   `git clone` — создание копии удаленного репозитория на локальном компьютере, а также создании копии на удаленном репозитории с локального компьютера.
    -   в локальном репозитории появляется новая ветка с именем origin/master — копией удаленного репозитория, где origin/ — имя репозитория на удаленном сервере.
-   `git fetch` — извлечение данных из удаленного репозитория.
    -   при этом команда не модифицирует ваш код и не сливает ветки воедино. Команда лишь скачивает необходимые данные, которые еще предстоит вручную слить с вашими данными.
-   `git pull` — это скачивание и слияние удаленного кода с вашим.
    -   это — выполнение двух последовательных команд: `git fetch & git merger origin/master`.
-   `git fakeTeamwork [newBranch X]`- инициализация псевдо коммита на удаленном сервере (будто этот коммит был сделан другим человеком).
    -   newBranch — имя ветки в которую добавляются коммиты.
    -   Х — число коммитов.
-   `git push` — заливка своих изменений на удаленный репозиторий.
    -   если в удаленном репозитории есть расхождения — Гит не даст закачать только ваши изменения в репозиторий, он будет заставлять вас включать все существующие в самом репозитории изменения.
    -   в случае расхождений — следует перебазировать ваши наработки на самую последнюю версию удаленной ветки: `git fetch; git rebase origin/master; git push`. Или: `git fetch; git merge origin/master; git push`.
    -   перебазирование можно сделать и с помощью одной команды: git pull —rebase; git push (замещает две предыдущие команды из прошлого пункта: git fetch; git rebase origin/master и git fetch; git merge origin/master)
-   Слияние фича-бранней (веток вне master).
    -   `git branch -u original/master newBranch; git commit; git push` — отслеживание удаленной ветки




# Ссылки
___
##### Links

https://www.atlassian.com/ru/git/tutorials/learn-git-with-bitbucket-cloud
---
##### Источники
https://myatov.ru/news/git-dlja-novichkov/

https://git-scm.com/book/ru/v2/%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%B0%D1%8F-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B8-%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BE%D0%B2

https://russianblogs.com/article/28411556049/