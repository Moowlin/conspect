202208031453
Tags:
___
# Массивы

## Понятие массива. Объявление и инициализация массива

Массив — это последовательность элементов одного типа фиксированной длины. Объявление массива осуществляется следующим образом:
```go
var a [3]int
fmt.Println(a) // [0 0 0]
```

При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. [3]int не может просто так взаимодействовать с [5]int (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать int64 и int32.

Как мы увидели в приведенном примере, объявленный массив был при объявлении инициализирован нулевыми значениями (0 для int). Такое поведение не является стандартным, в частности в языках C / C++ объявленный массив нулевыми значениями не заполняется.

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):

```go
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```

Вместо явного указания длины массива мы можем указать символ многоточия (...) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений. Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию в [документации](https://golang.org/doc/effective_go.html#arrays).

Четвертый же способ инициализации позволяет явно указать значение, которое должно быть присвоено элементу массива с определенным индексом. В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены; как и прежде, неуказанные значения получают нулевое значение типа элемента.

## Сравнение массивов

Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:

```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).

## Обращение к элементам массива. Индексы
Для обращения к элементам массива применяются индексы - номера элементов. При этом нумерация элементов массива начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках. По индексу можно получить значение элемента, либо изменить его:

```go
package main

import "fmt"

func main() {   
    var numbers [5]int = [5]int{1,2,3,4,5}    

    fmt.Println(numbers[0])     // 1  
    fmt.Println(numbers[4])     // 5   

    numbers[0] = 87   

    fmt.Println(numbers[0])     // 87
}
```

Однако в большинстве случаев нам необходимо обратиться ко всем элементам массива и выполнить с ними определенную работу. Мы можем сделать это с помощью цикла:

 ```go
 := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}
```
Обратите внимание, что определяя условие продолжения выполнения цикла мы использовали встроенную функцию len(), возвращающую длину массива. Поскольку индексация элементов массива начинается с 0, то последний элемент массива a будет иметь индекс len(a) - 1.

При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

Range возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента. Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ \_. Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:

```go
a := [5]int{1, 2, 3, 4, 5}

for idx := range a {
    fmt.Println(a[idx])
}

for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}

for _, elem := range a {
    fmt.Println(elem)
}
```
Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив. В этом случае мы должны обращаться к элементам массива по индексу:

```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

# Срезы (слайсы, slices)
## Понятие среза

Срез — это последовательность элементов одного типа переменной длины.

Массивы и срезы тесно связаны. Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива. Длину массива изменять нельзя, а вот новые элементы в срез добавлять можно, так что в некоторых языках срезами называются динамические массивы.

Срез состоит из трех компонентов: указателя, длины и емкости:

-   указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
-   длина (length) — это количество элементов среза;
-   емкость (capacity) - количество элементов между началом среза и концом базового массива.

Длина и емкость среза могут быть определены при помощи встроенных функций len() и cap() соответственно.


## Создание среза
### Создание пустого среза

Пустой срез может быть создан аналогично созданию массива за тем исключением, что нам нет необходимости указывать длину среза, поскольку она изменяема. При создании пустого среза мы также можем инициализировать его, явно указав элементы среза. Давайте рассмотрим, чем различается создание массива и среза:
```go
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}

fmt.Println(a) // []
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12]
```

На этом способы создания среза в Go не заканчиваются. Для гибкого способа создания пустых срезов в Go существует встроенная функция make следующего вида:
```go
make([]T, length, capacity)
```
Чтобы разобраться с этой функцией нам нужно посмотреть, что происходит при создании пустого среза: Go создает массив какой-то длины. О понятии среза мы говорили выше: указатель среза будет указывать на первый элемент созданного массива, длина среза составит 0 (если мы явно не указали элементы среза), емкость необходимого массива будет определена Go самостоятельно.

Для чего нам может потребоваться явно указать длину и емкость среза:

-   для того, чтобы инициализировать нулевыми значениями элементы массива (длина среза);
-   для того, чтобы выделить нужное количество памяти для хранения массива, лежащего в основе нашего среза.

```go
a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0]
fmt.Println(a)
```

### Оператор среза

Оператор среза `s[i:j]` создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s). В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез. В итоге в полученном срезе будет j-i элементов.

Если значение i не указано, то применяется по умолчанию значение 0. Если значение j не указано, то вместо него используется длина исходной последовательности s.

```go
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"} // базовый массив

users1 := initialUsers[2:6] // с 3-го по 6-й
users2 := initialUsers[:4] // с 1-го по 4-й
users3 := initialUsers[3:] // с 4-го до конца

fmt.Println(users1) // [Kate Sam Tom Paul]
fmt.Println(users2) // [Bob Alice Kate Sam]
fmt.Println(users3) // [Sam Tom Paul Mike Robert]
```

## Встроенные функции для работы со срезами
Для работы со срезами в Go предусмотрены встроенные функции append и copy.

### Функция append - добавление элементов в срез

Функция append позволяет добавить в срез новый элемент, выглядит она следующим образом:

```go
func append(slice []Type, elems ...Type) []Type
```

В качестве первого аргумента функция получает срез, в который необходимо добавить новые элементы, второй и последующий элементы - это элементы совместимого со срезом типа, которые необходимо добавить в срез. Функция возвращает новый срез, содержащий ранее содержавшиеся в срезе элементы, а также новые элементы, переданные в качестве аргумента функции append. 

```go
a := []int{1, 2, 3}
a = append(a, 4, 5)

fmt.Println(a) // [1 2 3 4 5]
```

#### Немного сложного

Теперь самое время вернуться к вопросу о длине и емкости среза, чтобы в контексте работы функции append рассмотреть внутренне устройство срезов. Что произойдет, если добавить в срез длины N и такой же емкости элементов больше N? Посмотрим на примере:

```go
baseArray := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
fmt.Printf("Базовый массив: %v\n", baseArray)

baseSlice := baseArray[5:8]
fmt.Printf(
    "Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
    len(baseSlice),
    cap(baseSlice),
    baseSlice,
)

// Output:
// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
// Срез, основанный на базовом массиве длиной 3 и емкостью 5: [5 6 7]
```

Теперь проведем небольшую подготовительную работу. Мы знаем, что один из компонентов среза: указатель на элемент массива, который является первым элементом среза. Сохраним этот указатель в переменной pointer в виде строки (мы не будем его печатать, т.к. во время каждого исполнения программы он будет разным, но мы сможем использовать сохраненное значение для сравнения):
```go
pointer := fmt.Sprintf("%p", baseSlice)
```
_Напоминание: Конструкция %p говорит, что в качестве результата должен быть возвращен адрес элемента массива, на который ссылается baseSlice._
Теперь добавим новый элемент в наш срез и посмотрим, как это повлияет на наш базовый массив:

```go
baseSlice = append(baseSlice, 10)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 4 и емкостью 5: [5 6 7 10]
// true
```
Мы видим, что изменился не только наш срез, но и базовый массив, на который ссылается срез. Длина среза изменилась автоматически. А теперь повторим предыдущую операцию, но добавим столько элементов, чтобы емкости среза не хватило:

```go
baseSlice = append(baseSlice, 11, 12, 13)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
// false
```
Мы видим, что базовый массив не изменился, а наш срез теперь ссылается на другой массив и имеет емкость больше длины. Почему так произошло? При добавлении элементов в срез Go проверяет, достаточно ли емкости среза для добавления новых элементов в срез (т.е. есть ли еще место в массиве, на котором основан срез). Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а также добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go: создав один раз срез на основе массива достаточной нам длины, мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.

#### Использование append для удаления элемента из среза

В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:
```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

### Функция copy - копирование элементов среза
Сразу рассмотрим описание функции:

```go
func copy(dst, src []Type) int
```
Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:

```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

Почему мы явно указали длину создаваемого среза b? Потому что иначе функции было бы некуда копировать. Имей срез b длину 1, был бы скопирован 1 элемент из среза a.

## Особенности работы со срезами

Методики работы со срезами аналогичны работе с массивами с учетом тех особенностей, которые мы рассмотрели ранее. Последовательность элементов среза также можно обойти с использованием цикла, обращаясь к ним с использованием индекса или получая значение с использованием range.

Рассматривая эти темы помните о том, что срез по своей сути - [[GO_Указатели|указатель]] на массив, а это влияет на его поведение при передаче в качестве аргумента в функцию:

```go
func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}
```
В приведенном примере мы создали 2 функции: fnA и fnB. Первая получает в качестве аргумента массив из 3-х элементов, вторая - срез. Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что fnB работала с указателем на массив и изменила непосредственно сам массив, fnA же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.

# Ссылки
___
##### Links


---
##### Источники
